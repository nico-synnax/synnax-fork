# 25 - Effects

**Feature Name**: Effects <br />
**Status**: In Progress <br />
**Start Date**: 2025-05-23 <br />
**Authors**: Patrick Dotson & Emiliano Bonilla <br />

# 0 - Summary

In this RFC, we propose a new *effects*  feature for Synnax that allows for users to 
listen to arbitrary events in Synnax and conditionally trigger actions based on 
those events. As part of the implementation, I'll also propose a design for a new
graphical programming language called *Slate* that serves as a foundation for extending
Synnax's automation capabilities.

# 1 - Motivation

Automation is a core component of Synnax's value proposition. Our current Python and
Lua based automations served as a good starting point. These implementations allowed
software savvy teams to perform almost any task, and gave us many months of valuable 
feedback to understand what future automation capabilities should look like.

The earlier versions of Synnax are developer oriented, with the log-term goal of moving
towards more technician friendly interfaces as our user base grows. Now is the time
to start serious work towards this effort.

Motivation for an effects system arose from a desire to implement alarm capabilities 
in Synnax. By listening to thresholds on one or more channels, we'd send
a notification to the user and/or perform an action such as setting the value of a 
channel.

While evaluating an implementation of alarm functionality, we started to see
commonalities between automated control sequences, calculations, and the logic necessary
to implement alarms. By implementing a new alarm feature, there would now be *four* ways
to implement alarm functionality:

1. A Python script that consumes values from channels, checks if a threshold is crossed,
and sets the value of a notification channel.
2. A Lua embedded sequence that does the same thing as #1.
3. A calculated channel that returns a notification string if a threshold is crossed.
4. The new alarm system where a user configures a specific condition, threshold, and
action from the Console.

While a user tailored alarm dialog would be the most intuitive solution, the quantity
distinct ways to implement the same functionality raises questions surrounding Synnax's
broader automation strategy.

The next section of this RFC reasons about this strategy, and proposes a new
path forward.

# 2 - Strategy

## 2.1 - Events and Actions

An automation is a sequence of actions triggered by a set of events. All events in 
Synnax are represented by (A) a new value being written to a channel, or (B) a fixed
time interval.

(A) Changes in a channel's value can represent:

- A sensor value changing
- An actuator being activated
- A new data structure being create (i.e. range, channel, etc.)
- Control transfers
- State changes of tasks, sequences
- Users pressing buttons on schematics
- Arbitrary messages sent programmatically

(B) A fixed time interval represents:

- A loop iteration in a real-time control sequence
- A cron-job running at specific times

Categories (A) and (B) are not mutually exclusive. For example, time-based events
can be triggered by a channel receiving a timer message from a remote location.

A key characteristic is that there are a fundamentally limited set of easily
classifiable events.

What's relevant to note is that there are a fundamentally limited set of easily 
classifiable events.

Actions are more varied. Most are implement by writing values to channels, such as:

- Sending alarm notifications
- Commanding actuators
- Starting and stopping automations

But they can also be:

- Creating new data structures (i.e. range, channel, etc.)
- Sending messages over arbitrary protocols (Modbus, MQTT, Kafka, etc.)
- Performing jobs such as removing stale telemetry.

## 2.2 - Automation Execution Context & Runtimes

The `action -> event` flow does not provide a complete picture for the requirements of
an automation in the context of Synnax. It's also critical to understand the environment
an automation is executed in and the the constraints under which it must operate.

### 2.2.0 - General Execution Models

When building dynamically executed automations, there are four primary execution models:

1. **Step-Based Execution**: Automations are evaluated on a fixed time interval or
   "tick." At each tick, the system checks for event conditions and executes 
   corresponding actions. This model is ideal for real-time control and monitoring 
   scenarios where timing consistency is critical.

2. **Event-Driven Execution**: Automations are triggered immediately in response to 
    event occurrences. For instance, when a value changes on a specific channel, the 
    associated actions execute. This model excels in reactive systems that respond to 
    sensor data, user input, or external messages with minimal latency.

3. **Fixed-Point Iteration**: Automations are continuously evaluated in a loop until a 
    stable state is reachedâ€”i.e., until further evaluation produces no changes in state 
    or outputs. This model is useful in scenarios where logic must converge, such as 
    dependency resolution or stable control loops.

4. **Control Flow Interpretation**: Automations are represented as structured programs, 
    with explicit logic constructs such as `if`, `while`, and `switch`. Execution follows 
    the control path, allowing for complex procedural logic. This model is suited for 
    implementing sophisticated logic flows and user-defined scripts.

### 2.2.1 - Practical Examples

Different automations in Synnax benefit from different execution models. 

**Example 1 - Real-Time Control Loops**: A real-time control sequence such as a bang-bang
vale control loop must execute at a predictable time interval. This execution model
is comparable to our current, Lua based embedded control sequences.

**Example 2 - Calculations**: A calculated channel must be executed when any of its
input parameters change. Running on a fixed time interval has the risk for
over-calculating on stale values or under-calculation by not re-running the calculation
if the values change too fast for the fixed time interval. An event-driven model is
much better suited for this use case, as it will re-run the calculation whenever values
change.

**Example 3 - Effects**: Pretty much the same story as a calculation.

**Example 4 - Supervisory Procedures**: Supervisory procedures control overall execution
of an operation through a step of steps. A rocket engine test, for example, would have
setup, pressurization, redline checks, ignition, steady state, and shutdown steps. While
these can be modeled as separate states within a control loop, it's more natural to 
understand them in a procedural manner with control flow to guard or change the
execution process across the steps. This type of automation is best modeled using
control flow interpretation, where blocks like `if`, `while`, and `switch` are used
to guard or change the execution process across the steps.

### 2.2.2 - Execution Context

As a parallel to runtimes, execution environments are also varied. Certain automations
lend themselves to running directly on real-time controllers in memory-predictable
languages like C or C++. Other automations, such as events or supervisory procedures,
benefit from flexible, event oriented languages like Go.

## 2.2 - Multiple Interfaces for Defining Automations

If every automation is simply events triggering actions, shouldn't there be a single,
consolidated interface for defining them?

Probably not. A good user experience guides interactions towards the simplest path
for implementing the desired functionality. Part of this process involves
restricting the options available in order to simplify a workflow.

Take a Linear issue as an example. The `priority` field could just be defined as another
set of labels that can be added to the issue. By adding a specific field, however,
Linear is guiding the user towards the understanding that priority is a first class
field that probably should be defined. It also simplifies common tasks like filtration,
and visual grepping for issues by priority.

So, even though we could implement alarms by making the user write and run Python
scripts for everything, this functionality adds (1) a higher learning curve, (2) longer
implementation times, and (3) additional vectors for introducing bugs.

The conclusion here is that **we should** provide independent interfaces for performing
clearly distinct tasks. Notably, this doesn't necessarily mean that the implementation 
underneath the hood should not be consolidated.

## 2.3 - Separation Between Interface, Specification, and Runtime

The next question is how to separate the interface, specification, and runtime of an
automation.

_Interface_ - How the user defines, monitors, and interacts with an automation.
_Specification_ - How the automation is stored and retrieved from Synnax.
_Runtime_ - Where and how the automation is executed.

We propose multiple interfaces for defining automations, a single specification format,
and multiple runtimes for executing them.

## 2.4 - Slate - A Single Specification

If there is a limited set of possible events and actions, then it's natural to defined
a single specification that can encapsulate every automated flow a user may want to run.

A single specification format also allows for standardization and validation of common
logical operators such as `==`, `!=`, `>`, `<`, `>=`, `<=`, etc. Regardless of the 
underlying runtime (fixed-point iteration, event-driven, control flow interpretation),
the inputs, outputs, and fundamental logic of these operations remain the same.

While logical operators are the same, certain runtimes may not support certain
statements and may benefit from additional features. For example, fixed-point iteration
would not support a `while` statement, while procedural runtimes would.

Navigating the commonalities and differences between runtimes while maintaining a
common specification format has yet to be solved effectively.

## 2.5 - Multiple Runtimes for Executing Slate Specifications

The runtime is the final piece of the puzzle. As detailed in Section 2.2, different
runtimes perform better for different automations. As a result, we propose multiple
runtimes for executing Slate specifications depending on the automation type.

While implementations of each runtime will occur over time, the following three
execution models will cover all envisioned use cases for automations within Synnax:

1. **Event-Driven Runtime**: Used for calculations and effects, the event driven runtime
will execute on the server to respond to changes in channel values and other events
that occur throughout the cluster. **This will be the first runtime to be implemented
for our alarms functionality.**

2. **Fixed-Point Iteration Runtime**: Used for real-time control loops, the fixed-point
iteration runtime will execute on Synnax's device driver using a C++ runtime, and will
be designed as a replacement for our current Lua based embedded control sequences that
run on real-time operating systems.

3. **Control Flow Interpretation Runtime**: Used for supervisory procedures, the control
flow runtime will allow for the execution of procedural logic that requires a higher
degree of flexibility, but lower degree of performance than the fixed-point iteration
runtime. As this runtime is the closest to a general purpose programming language,
it will be the most complex and last to be implemented.

## 3 - Design

## 3.1 - Slate Specification

The Slate specification uses a graph representation to define the flow of
data and logic through the automation. As with any graphs, there are nodes
and edges.

### 3.1.0 - The Persisted Graph Data Structure

#### 3.1.0.0 - Node

A node is the basic building block of the Slate specification, and defines an isolated execution unit that can take in values through inputs and produce values through outputs.

```go
type Node struct {
    Key string 
    Type string 
    Config map[string]interface{} 
}
```

**Key** - A unique key for the node in the graph. This will most likely be a UUID.
**Type** - The type of node. This allows the specification and runtimes to determine:

1. What inputs the node accepts, whether they are required, and what data types are
   expected.
2. The output(s) the node produces and their data type.
3. How to parse parameters passed to the node via `Config`.
4. In the runtime, what implementation to use to execute the node.

**Config** - Parameters defined by the user to be passed as configuration parameters
to the node.

_An aside on state_ - The `Config` field is used to pass static parameters to the node, and is not modified during runtime. Nodes that must maintain state across events/iterations must do so through their runtime implementation.

#### 3.1.0.1 - Edge

```go
type Handle struct {
    Node string 
    Key string 
}
```

**Node** - The node that the handle is attached to.
**Key** - The specific input or output of the node that the handle is attached to.

```go
type Edge struct {
    Source Handle 
    Sink Handle 
```

**Source** - The source node and input key of the edge.
**Sink** - The sink node and output key of the edge.

#### 3.1.0.2 - Graph

```go
type Graph struct {
    Nodes []Node 
    Edges []Edge 
}
```

### 3.1.1 - Schemas

In order to validate the relationships between nodes and edges, nodes of a particular
type also define a schema for their inputs and outputs.

```go
type InputSchema struct {
    Key string
    AcceptsDataType func(dt string) bool
}
```

**Key** - The key of the input.
**AcceptsDataType** - A function that returns true if the output of the source node is
compatible with the input of the sink node. This allows for a particular node to handle
a variety of data types.

```go
type OutputSchema struct {
    Key string
    DataType string
}
```

**Key** - The key of the output.
**DataType** - The data type of the output. The graph is statically typed, so all nodes must have a pre-defined set of outputs.

```go
type NodeSchema struct {
    Type string
    Inputs []InputSchema
    Outputs []OutputSchema
}
```

**Type** - The type of node.
**Inputs** - The inputs of the node.
**Outputs** - The outputs of the node.

### 3.1.2 - Validating the Specification

Validating the specification is a three step process:

1. Ensure that all nodes have a valid type.
2. Call a validator for each node type to:
   a. Ensure that all configuration parameters have the correct types and are within a
   specified set of bounds.
   b. Define the schema for the node.
3. Validate that all edges have valid source and sink nodes that are compatible with the schema for each node.

### 3.2 - Event-Driven Runtime

### 3.3 - Effects User Interface