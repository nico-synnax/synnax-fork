# 25 - Effects

**Feature Name**: Effects <br />
**Status**: In Progress <br />
**Start Date**: 2025-05-23 <br />
**Authors**: Emiliano Bonilla <br />

## 0 - Summary

In this RFC, we propose a new *effects*  feature for Synnax that allows for users to 
listen to arbitrary events in Synnax and conditionally trigger actions based on 
those events. As part of the implementation, I'll also propose a design for a new
graphical programming language called *Slate* that serves as a foundation for extending
Synnax's automation capabilities.

## 1 - Motivation

Automation is a core component of Synnax's value proposition. Our current Python and
Lua based automations served as a good starting point. These implementations allowed
software savvy teams to perform almost any task, and gave us many months of valuable 
feedback to understand what future automation capabilities should look like.

The earlier versions of Synnax are developer oriented, with the log-term goal of moving
towards more technician friendly interfaces as our user base grows. Now is the time
to start serious work towards this effort.

Motivation for an effects system originally arose from a desire to implement alarm
capabilities in Synnax. By listening to thresholds one one or more channels, we'd send
a notification to the user and/or perform an action such as setting the value of a 
channel.

While evaluating an implementation of alarm functionality, we started to see
commonalities between automated control sequences, calculations, and the logic necessary
to implement alarms. With a new alarm system, there would be *four* ways to implement
ana alarm:

1. A Python script that consumes values from channels, checks if a threshold is crossed,
and sets the value of a notification channel.
2. A Lua embedded sequence that does the same thing.
3. A calculated channel that returns a notification string if a threshold is crossed.
4. The new alarm system where a user configures a specific condition, threshold, and
action from the Console.

While an user tailored alarm dialog would be the most intuitive solution, so many
distinct ways to implement the same functionality raises questions surrounding Synnax's
broader automation strategy.

The subsequent section of this RFC reasons about this strategy, and proposes a new
path forward.

## 2 - Strategy

### 2.1 - Events and Actions

An automation is a sequence of actions triggered by a set of events. All events in 
Synnax are represented by (A) a new value being written to a channel, or (B) a fixed
time interval.

(A) Changes in a channel's value can represent:

- A sensor value changing
- An actuator being activated
- A new data structure being create (i.e. range, channel, etc.)
- Control transfers
- State changes of tasks, sequences
- Users pressing buttons on schematics
- Arbitrary messages sent programmatically

(B) A fixed time interval represents:

- A loop iteration in a real-time control sequence
- A cron-job running at specific times

Categories (A) and (B) are not mutually exclusive. For example, time-based events
can be triggered by a channel receiving a timer message from a remote location.

What's relevant to note is that there are a fundamentally limited set of easily 
classifiable events.

Actions are more varied. Although they are commonly values sent down a channel, they 
can also be:

- Creating new data structures (i.e. range, channel, etc.)
- Sending messages over arbitrary protocols (Modbus, MQTT, Kafka, etc.)
- Performing jobs such as removing stale telemetry.
- Sending an alarm notification.
- Opening and closing valves for a bang bang control sequence.

### 2.2 - Multiple Interfaces for Defining Automations

If every automation is simply events triggering actions, shouldn't there be a single,
consolidate interface for defining them?

Probably not. One of the key tenets of a good UX is to guide the user towards the
simplest path towards implementing desired functionality. Part of this process involves
restricting the options available in order to simplify a workflow.

Take a Linear issue as an example. The `priority` field could just be defined as another
set of labels that can be added to the issue. By adding a specific field, however,
Linear is guiding the user towards the understanding that priority is a first class
field that probably should be defined. It also simplifies common tasks like filtration,
and visual grepping for issues by priority.

So, even though we could implement alarms by making the user write and run Python
scripts for everything, this functionality adds (1) a higher learning curve, (2) longer
implementation times, and (3) additional vectors for introducing bugs.

The conclusion here is that **we should** provide independent interfaces for performing
clearly distinct tasks. Notably, this doesn't necessarily mean that the implementation 
underneath the hood should not be consolidated.

### 2.3 - Separation Between Interface, Specification, and Runtime

The next question is how to separate the interface, specification, and runtime of an
automation.

_Interface_ - How the user defines, monitors, and interacts with an automation.
_Specification_ - How the automation is stored and retrieved from Synnax.
_Runtime_ - Where and how the automation is executed.

We propose multiple interfaces for defining automations, a single specification format,
and multiple runtimes for executing them.

### 2.4 - Slate - A Single Specification

Section 2.1 established the limited set of events and actions that can be used to 
define an automation in Synnax. As a result, it makes sense to have a single
specification that can encapsulate the entire event -> action space.

This most natural way to represent this is as a graph.

### 2.5 - Multiple Runtimes for Executing Slate Specifications

