---
layout: "@/layouts/Reference.astro"
title: "Write Data"
description: "Use the C++ client to write data to a Synnax cluster."
next: "Stream Data"
nextURL: "/reference/cpp-client/stream-data"
prev: "Read Data"
prevURL: "/reference/cpp-client/read-data"
---

import { Divider } from "@synnaxlabs/pluto";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

The C++ client supports several different ways of writing data to a cluster. We can
write directly to a channel, write to multiple channels at once, or use the `write_frame`
method to write a `Frame` to the cluster.

<Divider.Divider direction="x" />

## Writing to a Channel

The simplest way to write data to a channel is to use the `write` method on the `Channel`
class:

```cpp
auto now = telem::Timestamp::now();
std::vector<double> data{1.0, 2.0, 3.0, 4.0, 5.0};
auto [err] = channel.write(now, data);
if (err) {
    // handle error
}
```

<Divider.Divider direction="x" />

## Writing to Multiple Channels

We can also write to multiple channels at once by calling the `write` method on
the `client`. This method takes a list of channel names/keys and a time range:

```cpp
synnax::Series s1{telem::FLOAT64, std::vector<double>{1.0, 2.0, 3.0, 4.0, 5.0}};
synnax::Series s2{telem::TIMESTAMP_T, std::vector<telem::Timestamp>{
    now,
    now + 1 * telem::SECOND,
    now + 2 * telem::SECOND,
    now + 3 * telem::SECOND,
    now + 4 * telem::SECOND
}};

auto fr = synnax::Frame{
    std::vector<synnax::ChannelKey>{ch1.key, ch2.key},
    std::vector<synnax::Series>{s1, s2}
};

auto [err] = client.write(fr);
if (err) {
    // handle error
}
```

<Divider.Divider direction="x" />

## Using a Writer

While the above methods are great for writing static, existing data, it's common
to write data in a streaming fashion as it's acquired. This is especially useful
for use in control sequences and live data processing. The `Writer` class is designed
for this use case (and is actually used under the hood by the other methods).

To keep things intuitive, the writer maintains a file-like interface that is similar
to Python's built-in file objects. There are a few key differences, the most
important being that writers are governed by a transaction. If you'd like to
learn more about transactions and how writes work in Synnax, check out the
[concepts](/reference/concepts/writes) page.

We'll create the following channels to use as examples:

```cpp
synnax::Channel index_ch{
    .name = "time",
    .data_type = synnax::TIMESTAMP_T,
    .is_index = true
};

auto err = client.channels.create(index_ch);
if (err) {
    // handle error
}

synnax::Channel data_ch{
    .name = "temperature",
    .data_type = synnax::FLOAT64,
    .index = index_ch.key
};

err = client.channels.create(data_ch);
if (err) {
    // handle error
}
```

To open the writer, we use the `telem.open_writer` method on the client and provide a
starting timestamp for the first sample and a list of channels we'd like to
write to:

```cpp
auto [writer, err] = client.telem.open_writer(synnax::WriterConfig{
    .start = telem::Timestamp::now(),
    .channels = std::vector<synnax::ChannelKey>{index_ch.key, data_ch.key}
});
if (err) {
    // handle error
}
for (int i = 0; i < 100; i++) {
    writer.write(synnax::Frame{
        std::vector<synnax::ChannelKey>{index_ch.key, data_ch.key},
        std::vector<synnax::Series>{
            synnax::Series{telem::TIMESTAMP_T, std::vector<telem::Timestamp>{
                telem::Timestamp::now() + i * telem::SECOND
            }},
            synnax::Series{telem::FLOAT64, std::vector<double>{i}}
        }
    });
}
auto err = writer.commit();
if (err) {
    // handle error
}
auto err = writer.close();
if (err) {
    // handle error
}
```

This will write 100 samples to the `temperature` channel, each spaced 1 second apart,
and then will commit the transaction, making the data available to read.

It's typical to write and commit millions of samples over the course of hours or
days, intermittently calling commit to ensure that the data is persisted to the
cluster.

### Auto-Commit

You can also configure a writer to automatically commit written data after each
write, making it immediately available for read access. To do this, set the
`enable_auto_commit` argument to `True` when opening the writer:

```cpp
auto [writer, err] = client.telem.open_writer(
    synnax::WriterConfig{
        .start = telem::Timestamp::now(),
        .channels = std::vector<synnax::ChannelKey>{index_ch.key, data_ch.key},
        .enable_auto_commit = true
    }
);
if (err) {
    // handle error
}
```

This will automatically commit the transaction after each write, making the data
available for read access immediately.
