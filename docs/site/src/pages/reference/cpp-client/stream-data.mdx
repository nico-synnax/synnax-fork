---
layout: "@/layouts/Reference.astro"
title: "Stream Data"
description: "Use the C++ client to stream data from a Synnax cluster."
next: "Ranges"
nextURL: "/reference/cpp-client/ranges"
prev: "Write Data"
prevURL: "/reference/cpp-client/write-data"
---

import { Divider } from "@synnaxlabs/pluto";
import { mdxOverrides } from "@/components/mdxOverrides";
export const components = mdxOverrides;

Streaming data is useful for real-time processing, visualization, and
monitoring. This page guides you through using the C++ client to stream data
from a Synnax cluster. If you'd like a conceptual overview of how streaming works
in Synnax, check out the [streams](/reference/concepts/streams) page.

<Divider.Divider direction="x" />

## Opening a Streamer

To start streaming data, call the `telem.open_streamer` method on the client and
provide a list of channels to stream:

```cpp
auto [streamer, err] = client.telem.open_streamer(synnax::StreamerConfig{
    .channels = std::vector<std::string>{"channel1", "channel2"}
});
if (err) {
    // handle error
}
```

<Divider.Divider direction="x" />

## Reading Frames

To read the next incoming frame, call the `read` method on the streamer:

```cpp
auto [frame, err] = streamer.read();
if (err) {
    // handle error
}
```

This call will block until a new frame is available.

### Specifying a Timeout

It's also possible to add a `timeout` parameter to the `read` method. If the timeout is
reached before a new frame is available, the method will return `None` instead of a frame:

```cpp
auto [frame, err] = streamer.read(telem::SECOND * 5);
if (err.matches(synnax::TIMEOUT_ERROR)) {
    // handle timeout
} else if (err) {
    // handle error
}
```

### Handling Partial Frames

When reading frames from a streamer, it's important to note that a frame may not contain
data for every channel specified when opening the streamer. For example,
if we're reading from two sensors, `temperature` and `pressure, that are being sampled
by different devices at different rates, we may receive a frame containing data only
for the first channel, followed by a frame containing only data for the second channel.

```cpp
auto [stream, err] = client.telem.open_streamer(synnax::StreamerConfig{
    .channels = std::vector<std::string>{"temperature", "pressure"}
});
if (err) {
    // handle error
}

auto [frame, err] = stream.read();
if (err) {
    // handle error
}
std::cout << frame[-1] << std::endl;
/// Output: {"temperature": 25.0}


auto [frame2, err2] = stream.read();
if (err2) {
    // handle error
}
std::cout << frame2[-1] << std::endl;
/// Output: {"pressure": 1013.25}

auto [frame3, err3] = stream.read();
if (err3) {
    // handle error
}
std::cout << frame3[-1] << std::endl;
/// Output: {"temperature": 25.1, "pressure": 1013.25}
```

<Divider.Divider direction="x" />

## Updating the Channel List

If you want to update the list of channels being streamed, you can call the
`update_channels` method on the streamer:

```cpp
auto err = streamer.update_channels(
    std::vector<std::string>{"channel3", "channel4"}
);
if (err) {
    // handle error
}
auto err = streamer.update_channels(
    std::vector<synnax::ChannelKey>{ch1.key, ch2.key}
);
if (err) {
    // handle error
}
```

<Divider.Divider direction="x" />

## Closing the Streamer

After you're done streaming, it's essential that you call the `close` method on
the streamer to release the network connection and other related resources:

```cpp
auto err = streamer.close();
if (err) {
    // handle error
}
```
