//go:build ignore

package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

// TypeInfo represents a type and its Go/WASM representations
type TypeInfo struct {
	IRType   string // e.g., "u8", "i32", "f64"
	GoType   string // e.g., "uint8", "int32", "float64"
	WasmType string // e.g., "uint32", "uint32", "float64"
	Is64Bit  bool   // whether this type uses 64-bit WASM representation
}

var types = []TypeInfo{
	{"u8", "uint8", "uint32", false},
	{"u16", "uint16", "uint32", false},
	{"u32", "uint32", "uint32", false},
	{"u64", "uint64", "uint64", true},
	{"i8", "int8", "uint32", false},
	{"i16", "int16", "uint32", false},
	{"i32", "int32", "uint32", false},
	{"i64", "int64", "uint64", true},
	{"f32", "float32", "float32", false},
	{"f64", "float64", "float64", true},
	{"string", "uint32", "uint32", false}, // string handles are uint32
}

const bindingsTemplate = `// Code generated by go generate; DO NOT EDIT.

package runtime

import (
	"context"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
)

// Bindings provides type-safe bindings for all runtime operations
type Bindings struct {
	// Channel operations - use proper Go types, handle WASM conversion internally
{{range .Types}}	ChannelRead{{.IRType | title}}         func(context.Context, uint32) {{.GoType}}
	ChannelWrite{{.IRType | title}}        func(context.Context, uint32, {{.GoType}})
	ChannelBlockingRead{{.IRType | title}} func(context.Context, uint32) {{.GoType}}
{{end}}

	// State operations - use proper Go types
{{range .Types}}	StateLoad{{.IRType | title}}  func(context.Context, uint32, uint32) {{.GoType}}
	StateStore{{.IRType | title}} func(context.Context, uint32, uint32, {{.GoType}})
{{end}}

	// Series operations
{{range .NumericTypes}}	SeriesCreateEmpty{{.IRType | title}}   func(context.Context, uint32) uint32
	SeriesSetElement{{.IRType | title}}    func(context.Context, uint32, uint32, {{.GoType}})
	SeriesIndex{{.IRType | title}}         func(context.Context, uint32, uint32) {{.GoType}}

	// Series arithmetic - take proper Go types for scalars
	SeriesElementAdd{{.IRType | title}}    func(context.Context, uint32, {{.GoType}}) uint32
	SeriesElementSub{{.IRType | title}}    func(context.Context, uint32, {{.GoType}}) uint32
	SeriesElementMul{{.IRType | title}}    func(context.Context, uint32, {{.GoType}}) uint32
	SeriesElementDiv{{.IRType | title}}    func(context.Context, uint32, {{.GoType}}) uint32

	// Series arithmetic - series-to-series operations
	SeriesSeriesAdd{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesSeriesSub{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesSeriesMul{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesSeriesDiv{{.IRType | title}}     func(context.Context, uint32, uint32) uint32

	// Series comparison operations
	SeriesCompareGT{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesCompareLT{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesCompareGE{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesCompareLE{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesCompareEQ{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
	SeriesCompareNE{{.IRType | title}}     func(context.Context, uint32, uint32) uint32
{{end}}

	// Generic operations
	Now               func(context.Context) uint64
	Len               func(context.Context, uint32) uint64
	Panic             func(context.Context, uint32, uint32)
	MathPowF32        func(context.Context, float32, float32) float32
	MathPowF64        func(context.Context, float64, float64) float64
	SeriesLen         func(context.Context, uint32) uint64
	SeriesSlice       func(context.Context, uint32, uint32, uint32) uint32
	StringFromLiteral func(context.Context, uint32, uint32) uint32
	StringConcat      func(context.Context, uint32, uint32) uint32
	StringEqual       func(context.Context, uint32, uint32) uint32
	StringLen         func(context.Context, uint32) uint32
}

// NewBindings creates a new Bindings with stub implementations
func NewBindings() *Bindings {
	b := &Bindings{}
	b.setDefaultStubs()
	return b
}

// setDefaultStubs sets panic stubs for all unimplemented functions
func (b *Bindings) setDefaultStubs() {
	// Channel operation stubs
{{range .Types}}	if b.ChannelRead{{.IRType | title}} == nil {
		b.ChannelRead{{.IRType | title}} = func(ctx context.Context, channelID uint32) {{.GoType}} {
			panic("channel_read_{{.IRType}} not implemented")
		}
	}
	if b.ChannelWrite{{.IRType | title}} == nil {
		b.ChannelWrite{{.IRType | title}} = func(ctx context.Context, channelID uint32, value {{.GoType}}) {
			panic("channel_write_{{.IRType}} not implemented")
		}
	}
	if b.ChannelBlockingRead{{.IRType | title}} == nil {
		b.ChannelBlockingRead{{.IRType | title}} = func(ctx context.Context, channelID uint32) {{.GoType}} {
			panic("channel_blocking_read_{{.IRType}} not implemented")
		}
	}
{{end}}

	// State operation stubs
{{range .Types}}	if b.StateLoad{{.IRType | title}} == nil {
		b.StateLoad{{.IRType | title}} = func(ctx context.Context, taskID uint32, key uint32) {{.GoType}} {
			panic("state_load_{{.IRType}} not implemented")
		}
	}
	if b.StateStore{{.IRType | title}} == nil {
		b.StateStore{{.IRType | title}} = func(ctx context.Context, taskID uint32, key uint32, value {{.GoType}}) {
			panic("state_store_{{.IRType}} not implemented")
		}
	}
{{end}}

	// Series operation stubs
{{range .NumericTypes}}	if b.SeriesCreateEmpty{{.IRType | title}} == nil {
		b.SeriesCreateEmpty{{.IRType | title}} = func(ctx context.Context, length uint32) uint32 {
			panic("series_create_empty_{{.IRType}} not implemented")
		}
	}
	if b.SeriesSetElement{{.IRType | title}} == nil {
		b.SeriesSetElement{{.IRType | title}} = func(ctx context.Context, handle uint32, index uint32, value {{.GoType}}) {
			panic("series_set_element_{{.IRType}} not implemented")
		}
	}
	if b.SeriesIndex{{.IRType | title}} == nil {
		b.SeriesIndex{{.IRType | title}} = func(ctx context.Context, handle uint32, index uint32) {{.GoType}} {
			panic("series_index_{{.IRType}} not implemented")
		}
	}

	// Series arithmetic stubs
	if b.SeriesElementAdd{{.IRType | title}} == nil {
		b.SeriesElementAdd{{.IRType | title}} = func(ctx context.Context, handle uint32, value {{.GoType}}) uint32 {
			panic("series_element_add_{{.IRType}} not implemented")
		}
	}
	if b.SeriesElementSub{{.IRType | title}} == nil {
		b.SeriesElementSub{{.IRType | title}} = func(ctx context.Context, handle uint32, value {{.GoType}}) uint32 {
			panic("series_element_sub_{{.IRType}} not implemented")
		}
	}
	if b.SeriesElementMul{{.IRType | title}} == nil {
		b.SeriesElementMul{{.IRType | title}} = func(ctx context.Context, handle uint32, value {{.GoType}}) uint32 {
			panic("series_element_mul_{{.IRType}} not implemented")
		}
	}
	if b.SeriesElementDiv{{.IRType | title}} == nil {
		b.SeriesElementDiv{{.IRType | title}} = func(ctx context.Context, handle uint32, value {{.GoType}}) uint32 {
			panic("series_element_div_{{.IRType}} not implemented")
		}
	}

	// Series-to-series arithmetic stubs
	if b.SeriesSeriesAdd{{.IRType | title}} == nil {
		b.SeriesSeriesAdd{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_series_add_{{.IRType}} not implemented")
		}
	}
	if b.SeriesSeriesSub{{.IRType | title}} == nil {
		b.SeriesSeriesSub{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_series_sub_{{.IRType}} not implemented")
		}
	}
	if b.SeriesSeriesMul{{.IRType | title}} == nil {
		b.SeriesSeriesMul{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_series_mul_{{.IRType}} not implemented")
		}
	}
	if b.SeriesSeriesDiv{{.IRType | title}} == nil {
		b.SeriesSeriesDiv{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_series_div_{{.IRType}} not implemented")
		}
	}

	// Series comparison stubs
	if b.SeriesCompareGT{{.IRType | title}} == nil {
		b.SeriesCompareGT{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_gt_{{.IRType}} not implemented")
		}
	}
	if b.SeriesCompareLT{{.IRType | title}} == nil {
		b.SeriesCompareLT{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_lt_{{.IRType}} not implemented")
		}
	}
	if b.SeriesCompareGE{{.IRType | title}} == nil {
		b.SeriesCompareGE{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_ge_{{.IRType}} not implemented")
		}
	}
	if b.SeriesCompareLE{{.IRType | title}} == nil {
		b.SeriesCompareLE{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_le_{{.IRType}} not implemented")
		}
	}
	if b.SeriesCompareEQ{{.IRType | title}} == nil {
		b.SeriesCompareEQ{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_eq_{{.IRType}} not implemented")
		}
	}
	if b.SeriesCompareNE{{.IRType | title}} == nil {
		b.SeriesCompareNE{{.IRType | title}} = func(ctx context.Context, handle1 uint32, handle2 uint32) uint32 {
			panic("series_compare_ne_{{.IRType}} not implemented")
		}
	}
{{end}}

	// Generic operation stubs
	if b.Now == nil {
		b.Now = func(ctx context.Context) uint64 {
			panic("now() not implemented")
		}
	}
	if b.Len == nil {
		b.Len = func(ctx context.Context, handle uint32) uint64 {
			panic("len() not implemented")
		}
	}
	if b.Panic == nil {
		b.Panic = func(ctx context.Context, ptr uint32, len uint32) {
			panic("panic() called")
		}
	}
	if b.MathPowF32 == nil {
		b.MathPowF32 = func(ctx context.Context, base, exp float32) float32 {
			panic("math_pow_f32() not implemented")
		}
	}
	if b.MathPowF64 == nil {
		b.MathPowF64 = func(ctx context.Context, base, exp float64) float64 {
			panic("math_pow_f64() not implemented")
		}
	}
	if b.SeriesLen == nil {
		b.SeriesLen = func(ctx context.Context, handle uint32) uint64 {
			panic("series_len() not implemented")
		}
	}
	if b.SeriesSlice == nil {
		b.SeriesSlice = func(ctx context.Context, handle uint32, start uint32, end uint32) uint32 {
			panic("series_slice() not implemented")
		}
	}
	if b.StringFromLiteral == nil {
		b.StringFromLiteral = func(ctx context.Context, ptr uint32, len uint32) uint32 {
			panic("string_from_literal() not implemented")
		}
	}
	if b.StringConcat == nil {
		b.StringConcat = func(ctx context.Context, s1 uint32, s2 uint32) uint32 {
			panic("string_concat() not implemented")
		}
	}
	if b.StringEqual == nil {
		b.StringEqual = func(ctx context.Context, s1 uint32, s2 uint32) uint32 {
			panic("string_equal() not implemented")
		}
	}
	if b.StringLen == nil {
		b.StringLen = func(ctx context.Context, s uint32) uint32 {
			panic("string_len() not implemented")
		}
	}
}

// Bind registers all runtime functions with the wazero runtime using conversion wrappers
func (b *Bindings) Bind(ctx context.Context, rt wazero.Runtime) error {
	hostBuilder := rt.NewHostModuleBuilder("env")

	// Bind channel operations with type conversion wrappers
{{range .Types}}	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapChannelRead{{.IRType | title}}()).Export("channel_read_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapChannelWrite{{.IRType | title}}()).Export("channel_write_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapChannelBlockingRead{{.IRType | title}}()).Export("channel_blocking_read_{{.IRType}}")
{{end}}

	// Bind state operations with type conversion wrappers
{{range .Types}}	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapStateLoad{{.IRType | title}}()).Export("state_load_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapStateStore{{.IRType | title}}()).Export("state_store_{{.IRType}}")
{{end}}

	// Bind series operations with type conversion wrappers
{{range .NumericTypes}}	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCreateEmpty{{.IRType | title}}).Export("series_create_empty_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesSetElement{{.IRType | title}}()).Export("series_set_element_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesIndex{{.IRType | title}}()).Export("series_index_{{.IRType}}")

	// Series arithmetic operations
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesElementAdd{{.IRType | title}}()).Export("series_element_add_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesElementSub{{.IRType | title}}()).Export("series_element_sub_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesElementMul{{.IRType | title}}()).Export("series_element_mul_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.wrapSeriesElementDiv{{.IRType | title}}()).Export("series_element_div_{{.IRType}}")

	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesSeriesAdd{{.IRType | title}}).Export("series_series_add_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesSeriesSub{{.IRType | title}}).Export("series_series_sub_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesSeriesMul{{.IRType | title}}).Export("series_series_mul_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesSeriesDiv{{.IRType | title}}).Export("series_series_div_{{.IRType}}")

	// Series comparison operations
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareGT{{.IRType | title}}).Export("series_compare_gt_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareLT{{.IRType | title}}).Export("series_compare_lt_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareGE{{.IRType | title}}).Export("series_compare_ge_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareLE{{.IRType | title}}).Export("series_compare_le_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareEQ{{.IRType | title}}).Export("series_compare_eq_{{.IRType}}")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesCompareNE{{.IRType | title}}).Export("series_compare_ne_{{.IRType}}")
{{end}}

	// Bind generic operations (no conversion needed)
	hostBuilder.NewFunctionBuilder().WithFunc(b.Now).Export("now")
	hostBuilder.NewFunctionBuilder().WithFunc(b.Len).Export("len")
	hostBuilder.NewFunctionBuilder().WithFunc(b.Panic).Export("panic")
	hostBuilder.NewFunctionBuilder().WithFunc(b.MathPowF32).Export("math_pow_f32")
	hostBuilder.NewFunctionBuilder().WithFunc(b.MathPowF64).Export("math_pow_f64")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesLen).Export("series_len")
	hostBuilder.NewFunctionBuilder().WithFunc(b.SeriesSlice).Export("series_slice")
	hostBuilder.NewFunctionBuilder().WithFunc(b.StringFromLiteral).Export("string_from_literal")
	hostBuilder.NewFunctionBuilder().WithFunc(b.StringConcat).Export("string_concat")
	hostBuilder.NewFunctionBuilder().WithFunc(b.StringEqual).Export("string_equal")
	hostBuilder.NewFunctionBuilder().WithFunc(b.StringLen).Export("string_len")

	_, err := hostBuilder.Instantiate(ctx)
	return err
}

// Type conversion wrapper functions
{{range .Types}}
// Channel operation wrappers for {{.IRType}}
func (b *Bindings) wrapChannelRead{{.IRType | title}}() func(context.Context, uint32) {{.WasmType}} {
	return func(ctx context.Context, channelID uint32) {{.WasmType}} {
		result := b.ChannelRead{{.IRType | title}}(ctx, channelID)
		return {{.WasmType}}(result)
	}
}

func (b *Bindings) wrapChannelWrite{{.IRType | title}}() func(context.Context, uint32, {{.WasmType}}) {
	return func(ctx context.Context, channelID uint32, value {{.WasmType}}) {
		b.ChannelWrite{{.IRType | title}}(ctx, channelID, {{.GoType}}(value))
	}
}

func (b *Bindings) wrapChannelBlockingRead{{.IRType | title}}() func(context.Context, uint32) {{.WasmType}} {
	return func(ctx context.Context, channelID uint32) {{.WasmType}} {
		result := b.ChannelBlockingRead{{.IRType | title}}(ctx, channelID)
		return {{.WasmType}}(result)
	}
}

// State operation wrappers for {{.IRType}}
func (b *Bindings) wrapStateLoad{{.IRType | title}}() func(context.Context, uint32, uint32) {{.WasmType}} {
	return func(ctx context.Context, taskID uint32, key uint32) {{.WasmType}} {
		result := b.StateLoad{{.IRType | title}}(ctx, taskID, key)
		return {{.WasmType}}(result)
	}
}

func (b *Bindings) wrapStateStore{{.IRType | title}}() func(context.Context, uint32, uint32, {{.WasmType}}) {
	return func(ctx context.Context, taskID uint32, key uint32, value {{.WasmType}}) {
		b.StateStore{{.IRType | title}}(ctx, taskID, key, {{.GoType}}(value))
	}
}
{{end}}

{{range .NumericTypes}}
// Series operation wrappers for {{.IRType}}
func (b *Bindings) wrapSeriesSetElement{{.IRType | title}}() func(context.Context, uint32, uint32, {{.WasmType}}) {
	return func(ctx context.Context, handle uint32, index uint32, value {{.WasmType}}) {
		b.SeriesSetElement{{.IRType | title}}(ctx, handle, index, {{.GoType}}(value))
	}
}

func (b *Bindings) wrapSeriesIndex{{.IRType | title}}() func(context.Context, uint32, uint32) {{.WasmType}} {
	return func(ctx context.Context, handle uint32, index uint32) {{.WasmType}} {
		result := b.SeriesIndex{{.IRType | title}}(ctx, handle, index)
		return {{.WasmType}}(result)
	}
}

// Series arithmetic wrappers for {{.IRType}}
func (b *Bindings) wrapSeriesElementAdd{{.IRType | title}}() func(context.Context, uint32, {{.WasmType}}) uint32 {
	return func(ctx context.Context, handle uint32, value {{.WasmType}}) uint32 {
		return b.SeriesElementAdd{{.IRType | title}}(ctx, handle, {{.GoType}}(value))
	}
}

func (b *Bindings) wrapSeriesElementSub{{.IRType | title}}() func(context.Context, uint32, {{.WasmType}}) uint32 {
	return func(ctx context.Context, handle uint32, value {{.WasmType}}) uint32 {
		return b.SeriesElementSub{{.IRType | title}}(ctx, handle, {{.GoType}}(value))
	}
}

func (b *Bindings) wrapSeriesElementMul{{.IRType | title}}() func(context.Context, uint32, {{.WasmType}}) uint32 {
	return func(ctx context.Context, handle uint32, value {{.WasmType}}) uint32 {
		return b.SeriesElementMul{{.IRType | title}}(ctx, handle, {{.GoType}}(value))
	}
}

func (b *Bindings) wrapSeriesElementDiv{{.IRType | title}}() func(context.Context, uint32, {{.WasmType}}) uint32 {
	return func(ctx context.Context, handle uint32, value {{.WasmType}}) uint32 {
		return b.SeriesElementDiv{{.IRType | title}}(ctx, handle, {{.GoType}}(value))
	}
}
{{end}}
`

func main() {
	// Filter numeric types (exclude string for series operations)
	var numericTypes []TypeInfo
	for _, t := range types {
		if t.IRType != "string" {
			numericTypes = append(numericTypes, t)
		}
	}

	data := struct {
		Types        []TypeInfo
		NumericTypes []TypeInfo
	}{
		Types:        types,
		NumericTypes: numericTypes,
	}

	// Custom template functions
	funcMap := template.FuncMap{
		"title": strings.Title,
	}

	tmpl := template.Must(template.New("bindings").Funcs(funcMap).Parse(bindingsTemplate))

	file, err := os.Create("static_bindings_generated.go")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		panic(err)
	}

	fmt.Println("Generated static_bindings_generated.go")
}
